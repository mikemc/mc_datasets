---
title: "Biases and calibration of the mock community spike-in"
output:
  html_document:
    toc: true
    toc_float: false
    code_folding: hide
    self_contained: true
---

# Setup

```{r package_options, include=FALSE, cache=FALSE}
knitr::opts_knit$set(progress=TRUE, verbose=TRUE)
# Global chunk options
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE, echo=TRUE, warning=FALSE,
    message=FALSE, fig.width=10, fig.height=8, include=TRUE)
# R options
options(width=100)
# options(digits=2)
```

```{r load_packages, include=T, cache=F}
# Use dev mode for latest version of ggplot
devtools::dev_mode(on = TRUE)
library(phyloseq)
library(tidyverse)
library(magrittr)

## Source bias estimation functions
devtools::load_all("~/active_research/src/metacal")

## Avoid confusing behavior from factor conversion
options(stringsAsFactors = FALSE)
```

```{r set_paths}
git_path <- file.path("~/active_research/metagenomics_calibration")
data_path <- file.path(git_path, "costea2017", "data")
metadata_path <- file.path(git_path, "costea2017", "metadata")
```

Phyloseq object with the species abundance table for Phase 3 samples:
```{r load_data}
ps <- readRDS(file.path(data_path, "phase3_phyloseq_with_tree.Rds"))
sample_data(ps) <- sample_data(ps) %>% 
    subset(select = -Lab) %>%
    within(Individual <- ifelse(Individual == "Mock-only", "M", Individual))
# Optionally, remove the extra two samples for the Q protocol
ps <- subset_samples(ps, !(Individual %in% c("A", "B")))
ps
```
We are going to subset to the mock taxa only. There are a few zero counts in
the rare taxon `Blautia_hansenii`. To deal with these I will add pseudocounts
to each taxon, equal to the minimal observed abundance in that sample.
```{r}
ps_nonzero <- ps %>% 
    transform_sample_counts(
        function (x) {
            min_nonzero <- min(x[x>0])
            x <- x + min_nonzero
            x / sum(x)
        })
```
Now we subset to the mock community taxa:
```{r}
mock_taxa <- c("Blautia_hansenii", "Clostridium_difficile",
    "Clostridium_perfringens", "Clostridium_saccharolyticum",
    "Fusobacterium_nucleatum", "Lactobacillus_plantarum",
    "Prevotella_melaninogenica", "Salmonella_enterica",
    "Vibrio_cholerae", "Yersinia_pseudotuberculosis")
phage <- "Salmonella_phage_Fels_1"
ps0 <- prune_taxa(mock_taxa, ps)
ps0
(sample_sums(ps0) / sample_sums(ps)) %>% sort
# And a version with no zeros:
ps1 <- prune_taxa(mock_taxa, ps_nonzero)
```
Note the large variation in the proportion of the sample made up by the
spike-in.

Expected mock community composition:
```{r}
mdf <- readxl::read_xlsx(file.path(metadata_path,
        "composition_of_mock_community.xlsx"), sheet=1)
mdf <- mdf %>% rename(Taxon = `Bacterial species`) %>%
    mutate(Taxon = str_extract(Taxon, "\\S+ \\S+"),
        Taxon = str_replace(Taxon, " ", "_"))
# I'm not sure what the "ground truth" is; for now, take as
# "bacterial cells in spike in Mix"
mdf0 <- mdf %>%
    select(Taxon, Cell_density = "bacterial cells in spike in Mix")
# Take the average of the log density as the estimated "truth" for the species
# where there are two measurements
mock_comp <- mdf0 %>%
    mutate(Log2_density = log2(Cell_density)) %>%
    group_by(Taxon) %>%
    summarize(Log2_density = mean(Log2_density))
# Compute the CLR
mock_comp <- mock_comp %>%
    mutate(CLR = Log2_density - mean(Log2_density))
# Verify species names match
setequal(taxa_names(ps0), mock_comp$Taxon)
# Phyloseq object with the truth
st.truth <- mock_comp %>% select(CLR) %>% as("matrix") %>% t
colnames(st.truth) <- mock_comp$Taxon
rownames(st.truth) <- "Truth"
st.truth <- otu_table(st.truth, taxa_are_rows = FALSE)
sam.truth <- data.frame(Protocol = "Truth", Phase = 3, row.names = "Truth") %>%
    sample_data
ps.truth.clr <- phyloseq(st.truth, sam.truth)
```

# Exploration

```{r, fig.height = 6, fig.width = 8}
ps1.clr <- ps1 %>% transform_sample_counts(clr, denom = "all")
p <- merge_phyloseq(ps1.clr, ps.truth.clr) %>%
    plot_pca
pd <- p$data %>%
    filter(Sample != "Truth")
truth <- p$data %>% 
    filter(Sample == "Truth")
ggplot(pd, aes(x = PC1, y = PC2, 
        color = Protocol, label = Individual)) +
    geom_text() +
    geom_point(data = truth, 
        aes(PC1, PC2),
        shape = 3, size = 4, inherit.aes = FALSE) + 
    labs(p$labels[1:2])
```

```{r, eval=F}
pcx <- merge_phyloseq(ps1.clr, ps.truth.clr) %>%
    otu_table %>%
    prcomp
biplot(pcx, scale = 1)
biplot(pcx, scale = 0)
```

Plot of species' abundance (as centered ratios) along with the expected values,
as in Costea2017 figure 6:
```{r}
# Order by expected abundance
species_ordered <- mock_comp %>%
    arrange(desc(CLR)) %$%
    Taxon
tb.clr <- ps1.clr %>% as_tibble %>%
    gather(key = "Taxon", value = "CLR", taxa_names(ps1.clr)) %>%
    mutate(Taxon = factor(Taxon, species_ordered))
# Points for step function of true abundances
lvls <- tb.clr$Taxon %>% levels
tb.step <- tibble(x = seq(0.5, 10.5, by = 0.5)) %>%
    mutate(x_int = pmin(floor(x + 0.5), 10),
        Taxon = lvls[x_int]) %>%
    left_join(mock_comp, by = "Taxon")
# The plot! note, doesn't work if I plot the geom_step before the text/points
ggplot(tb.clr, aes(x = Taxon, y = 2^CLR)) + 
    # geom_jitter(aes(x = Taxon, y = 2^CLR)) +
    geom_text(aes(x = Taxon, y = 2^CLR, color = Protocol, label = Individual), 
        position = position_jitter(width=0.25, height=0)) +
    geom_step(data = tb.step, aes(x = x, y = 2^CLR), alpha=0.3) +
    ylab("Abundance / geometric mean") +
    scale_y_log10(limits = c(1e-3, 1e2)) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

Phylogeny:
```{r}
plot(phy_tree(ps1))
# ape::add.scale.bar()
```

Some facts about species biology from the Microbe Directory:
```{r}
microbe_dir <- readr::read_csv(file.path("~/data", "2018-04-17_microbe-directory.csv"))
species_names <- taxa_names(ps1) %>% str_replace("_", " ")
# microbe_dir %>% filter(species %in% a) %>% select(family:species)
microbe_dir %>% filter(species %in% species_names) %>% 
    select(species, gram_stain, spore_forming, biofilm_forming, optimal_ph)
```
Note that *Clostridium saccharolyticum* is listed Gram-positive here, but as
negative in Costea2017 Fig 6 and at http://bacmap.wishartlab.com/organisms/1148

# Pairwise biases

Calculate the pairwise ratios for each sample:
```{r}
ratios <- otu_table(ps0) %>%
    pairwise_ratios
ratios_tb <- ratios %>%
    as_tibble(rownames = "Sample")
sam <- sample_data(ps0) %>% as_tibble
tb <- left_join(sam, ratios_tb, by = "Sample")
tb0 <- tb %>%
    gather(key = "Pair", value = "Ratio", colnames(ratios))
```

Plot the ratios with labels corresponding to `Individual`:
```{r}
ggplot(tb0, 
    aes(x = Pair, y = log2(Ratio), color = Protocol, label = Individual)) + 
    geom_text(position = position_jitter(width=0.25, height=0)) +
    # geom_jitter(width=0.25, height=0) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

Calculate the pairwise ratios relative to the "ground truth".
```{r}
# First get an otu table with the correct relative abundances for each sample
mat <- matrix(data = rep(2**mock_comp$Log2_density, nsamples(ps0)),
    nrow = nsamples(ps0), byrow = TRUE)
rownames(mat) <- sample_names(ps0)
colnames(mat) <- mock_comp$Taxon
# Get the taxa in the right order:
mat <- mat[, taxa_names(ps0)]
mock_mat <- mat
# Calc ratios
mock_ratios <- pairwise_ratios(mock_mat)
all.equal(colnames(ratios), colnames(mock_ratios))
all.equal(rownames(ratios), rownames(mock_ratios))
# Ratio of ratios
ratios_to_truth <- ratios / mock_ratios
# corner(ratios_to_truth, 2, 3)
```

```{r}
sam <- sample_data(ps0) %>% as_tibble
tb <- ratios_to_truth %>%
    as_tibble(rownames = "Sample") %>%
    left_join(sam, ratios_tb, by = "Sample")
tb0 <- tb %>%
    gather(key = "Pair", value = "Ratio", colnames(ratios))
ggplot(tb0, 
    aes(x = Pair, y = log2(Ratio), color = Protocol, label = Individual)) + 
    geom_text(position = position_jitter(width=0.25, height=0)) +
    # geom_jitter(width=0.25, height=0) +
    ylab("(Log2) Bias") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank()) +
    coord_cartesian(clip = "off")
```

# CLR biases

Aim is to calculate the CLR for each sample; subtract off the "truth"; and plot.
This should give a less redundant overview of how consistent bias is. In
future, may try while excluding Blautia from the denominator since it's one of
the species and has a few zero counts. For now, I'll work with the version with
zeros removed.
```{r}
observed <- otu_table(ps1) %>%
    transform_sample_counts(clr, denom = "all") %>%
    as("matrix")
expected <- otu_table(mock_mat, taxa_are_rows = FALSE) %>%
    transform_sample_counts(clr, denom = "all") %>%
    as("matrix")
clr_diff <- observed - expected
```

```{r}
tb.diff <- clr_diff %>% as_tibble(rownames = "Sample") %>%
    left_join(sam, ., by = "Sample") %>%
    gather(key = "Taxon", value = "Bias", taxa_names(ps1))
ggplot(tb.diff, 
    aes(x = Taxon, y = Bias, color = Protocol, label = Individual)) + 
    geom_text(position = position_jitter(width=0.25, height=0)) +
    # geom_jitter(width=0.25, height=0) +
    ylab("(Log2) Bias") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank()) +
    coord_cartesian(clip = "off")
```

# Calibration

## Calibration relative to the ground truth

First, we'll pick samples for estimation and cross validation.
```{r}
# Pick Individuals for estimation and evaluation
set.seed(2)
sam <- sample_data(ps1) %>% as_tibble
individuals_est <- base::sample(1:8, 3, replace = FALSE) %>% as.character
individuals_eval <- 1:8 %>% as.character %>% setdiff(individuals_est)
samples_est <- sam %>% 
    filter(Individual %in% individuals_est) %$%
    Sample
samples_eval <- sam %>% 
    filter(Individual %in% individuals_eval) %$%
    Sample
sample_data(ps1)[, "Set"] <- "Other"
sample_data(ps1)[samples_est, "Set"] <- "Est"
sample_data(ps1)[samples_eval, "Set"] <- "Eval"
```

Estimate biases:
```{r}
# (Re-generate ps1.clr to inherit the Set variable)
ps1.clr <- ps1 %>% transform_sample_counts(clr, denom = "all")
taxa <- taxa_names(ps1)
# Calculate the median clr across individuals within a protocol
tb0 <- ps1.clr %>% as_tibble %>%
    filter(Sample %in% samples_est) %>%
    group_by(Protocol) %>%
    summarize_at(taxa, median)
# Get the biases as the diff from truth
tb1 <- tb0 %>%
    gather(key = "Taxon", value = "CLR", taxa) %>%
    left_join(mock_comp, by = "Taxon", suffix = c("", "_true")) %>%
    mutate(Bias = CLR - CLR_true)
# Format for my calibration functions
biases <- tb1 %>%
    select(Taxon, Protocol, Bias) %>%
    spread(key = Protocol, value = Bias)
bias_mat <- biases %>% select(-Taxon) %>% as("matrix")
rownames(bias_mat) <- biases$Taxon
```
Calibrate the full set of samples.
```{r}
ps1.clr.cal <- calibrate_clr(ps1.clr, "Protocol", bias_mat)
```
Objects for computing distances:
```{r}
sample_data(ps.truth.clr)[, "Set"] <- "Other"
ps.clr <- prune_samples(samples_eval, ps1.clr) %>%
    merge_phyloseq(ps.truth.clr)
ps.clr.cal <- prune_samples(samples_eval, ps1.clr.cal) %>%
    merge_phyloseq(ps.truth.clr)
```
Distances before/after:
```{r}
d <- phyloseq::distance(ps.clr, method = 'euclidean')
d.cal <- phyloseq::distance(ps.clr.cal, method = 'euclidean')

tb0 <- usedist::dist_groups(d, sample_data(ps.clr)$Protocol) %>% as_tibble %>%
    mutate(Calibrated = "No")
tb1 <- usedist::dist_groups(d.cal, sample_data(ps.clr.cal)$Protocol) %>%
    as_tibble %>%
    mutate(Calibrated = "Yes")
tb2 <- bind_rows(tb0, tb1)
tb3 <- tb2 %>%
    filter(Item1 %in% samples_eval, Group2 == "Truth")
```

```{r, fig.height = 6}
# ggplot(tb3, aes(Label, Distance)) +
#     geom_violin(draw_quantiles = c(0.5)) + 
#     geom_jitter(width=0.25) + 
#     facet_wrap(~Calibrated)
# ggplot(tb3, aes(Label, Distance, color = Calibrated)) +
#     geom_jitter(width=0.25)
set.seed(2)
ggplot(tb3, aes(Calibrated, Distance, color = Group1)) +
    geom_violin(draw_quantiles = c(0.5)) + 
    geom_jitter(width=0.25) + 
    facet_wrap(~Group1)
```

TODO: look for a simpler way to do this procedure.

### Ordinations

Get a combined phyloseq with calibrated and uncalibrated samples and the truth
```{r}
sample_data(ps1.clr)$Calibrated <- "No"
sample_names(ps1.clr.cal) <- sample_names(ps1.clr.cal) %>% paste0(".cal")
sample_data(ps1.clr.cal)$Calibrated <- "Yes"
sample_data(ps.truth.clr)$Calibrated <- NA
ps2.clr <- merge_phyloseq(ps1.clr, ps1.clr.cal) %>%
    subset_samples(Individual %in% c(individuals_est, individuals_eval)) %>%
    merge_phyloseq(ps.truth.clr)
```

NMDS similar to PCA so currently not evaluated.
```{r, eval=F}
ord <- ordinate(ps2.clr, "NMDS", "euclidean")
```
```{r, eval=F, fig.height = 6, fig.width = 8}
p <- plot_ordination(ps2.clr, ord, type="samples", color="Protocol", 
    shape = "Calibrated")
pd <- p$data %>% as_tibble %>%
    mutate(ff = ifelse(Set == "Est", "bold", "plain"))
ggplot(pd, aes(x = NMDS1, y = NMDS2, 
       color = Calibrated, label = Protocol)) +
    geom_label(data = filter(pd, Set == "Est")) +
    geom_text(data = filter(pd, Set != "Est"))
```

PCA:
```{r, fig.height = 6, fig.width = 8}
p <- plot_pca(ps2.clr)
ggplot(p$data, aes(x = PC1, y = PC2, 
        color = Calibrated, label = Protocol)) +
    geom_label(data = filter(p$data, Set == "Est")) +
    geom_text(data = filter(p$data, Set != "Est")) +
    labs(p$labels[1:2])
```

A version with a skewed aspect ratio to better reflect the amount of variation
on each axis:
```{r, fig.height = 4, fig.width = 10}
ggplot(p$data, aes(x = PC1, y = PC2, 
        color = Calibrated, label = Protocol)) +
    geom_text() + 
    labs(p$labels[1:2]) + 
    coord_fixed(30 / 70)
# TODO: make this automatically get the true %'s
```

### Before and afters (prototypes for the poster)

```{r, fig.height = 6, fig.width = 8}
p <- plot_pca(ps2.clr)
pd <- p$data %>%
    filter(Sample != "Truth")
truth <- p$data %>% 
    filter(Sample == "Truth") %>% 
    select(-Calibrated)
ggplot(pd, aes(x = PC1, y = PC2, color = Protocol, label = Individual, 
        shape = Set)) +
    geom_point(data = truth, aes(x = PC1, y = PC2), 
        shape = 3, size = 5, inherit.aes = FALSE) +
    geom_point() +
    scale_shape_manual(breaks = c("Est", "Eval"), values = c(1, 16)) +
    facet_grid(Calibrated ~ .) +
    labs(p$labels[1:2]) +
    theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.ticks = element_blank())
```

```{r}
tb.clr <- ps2.clr %>% as_tibble %>%
    gather(key = "Taxon", value = "CLR", taxa_names(ps1.clr)) %>%
    mutate(Taxon = factor(Taxon, species_ordered)) %>%
    filter(Sample != "Truth")
lvls <- tb.clr$Taxon %>% levels
# Points for step function of true abundances
tb.step <- tibble(x = seq(0.5, 10.5, by = 0.5)) %>%
    mutate(x_int = pmin(floor(x + 0.5), 10),
        Taxon = lvls[x_int]) %>%
    left_join(mock_comp, by = "Taxon")
ggplot(tb.clr, aes(x = Taxon, y = 2^CLR)) + 
    geom_point(aes(x = Taxon, y = 2^CLR, color = Protocol, 
        shape = Set),
        position = position_jitter(width=0.25, height=0)) +
    geom_step(data = tb.step, aes(x = x, y = 2^CLR), alpha=0.3) +
    ylab("Abundance / geometric mean") +
    scale_y_log10() +
    # facet_grid(.~Calibrated) +
    facet_grid(Calibrated ~ .) +
    scale_shape_manual(breaks = c("Est", "Eval"), values = c(1, 16)) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```



### Bar plots

```{r}
ps2.ra <- ps2.clr %>%
    transform_sample_counts(function (x) {
        y <- 2**x
        y / sum(y)
    })
p <- plot_bar(ps2.ra)
pd <- p$data %>% as_tibble %>%
    rename(Taxon = OTU) %>%
    mutate(Taxon = factor(Taxon, species_ordered))
```

Let's first try just the Q samples.
```{r}
pd0 <- pd %>%
    filter(Protocol %in% c('Q', 'Truth'))
ggplot(pd0, aes(x = Sample, y = Abundance, fill = Taxon)) +
    geom_bar(stat = "identity") +
    facet_grid(. ~ Calibrated, 
        scales = "free", space = "free", shrink = TRUE)
# ggplot(pd0, aes(x = Sample, y = Abundance, fill = Taxon)) +
#     geom_bar(stat = "identity") +
#     facet_grid(. ~ Calibrated, 
#         scales = "free", space = "free", shrink = TRUE) +
#     scale_y_log10()
```

### Estimate of C. difficile absolute abundance

Calibration allows us to improve our estimates of pathogen abundance. Here,
I am using the most abundant of the mock community as a "spike-in" that is used
to obtain absolute abundance estimates of a pathogen, C. difficile. Note that
uncalibrated estimates systematically underestimate the abundance of C.
difficile; the calibrated estimates are much more accurate.
```{r}
# Get the relative abundances:
ps2.ra <- transform_sample_counts(ps2.clr, 
    function (x) {x <- 2**x; x / sum(x)})
# Estimate absolute abundances by treating Prevotella as the only spike-in
spikein <- "Prevotella_melaninogenica"
spikein_density <- mock_comp %>% filter(Taxon == spikein) %$% 2**Log2_density
# get the AAs 
ps2.aa <- ps2.ra %>%
    transform_sample_counts(function (x) {x * spikein_density / x[spikein]})
# Get a tibble for plotting
tb.aa <- as_tibble(ps2.aa) %>%
    filter(Set != "Other")
tb.aa0 <- tb.aa %>%
    filter(Set %in% "Eval")
# The true CD density
cdiff_density <- mock_comp %>% filter(Taxon == "Clostridium_difficile") %$%
    2**Log2_density
```

```{r, fig.height = 4, fig.width = 6, eval = F}
p <- ggplot(tb.aa0, aes(x = Clostridium_difficile, y = Protocol, 
        color = Calibrated)) +
    geom_vline(xintercept = cdiff_density, color = "grey") +
    geom_jitter(height = 0.1, width = 0) +
    scale_x_log10() +
    annotate("text", x = cdiff_density, y = Inf, label = "True abundance",
        vjust = -0.5) +
    theme(plot.margin = margin(t = 1, unit = "lines"))
    # theme(plot.margin = unit(c(1, 1, 0.5, 0.5), "lines"))
    # theme(plot.margin = unit(c(0.3,0.1,0.1,0.1), "inches"))
gt <- ggplot_gtable(ggplot_build(p))
gt$layout$clip[gt$layout$name == "panel"] <- "off"
grid::grid.draw(gt)
```
<!-- See this link for info about annotation outside plot. Note that it seems
to work for me with the regular annotate function, rather than annotate custom.
https://stackoverflow.com/questions/12409960/ggplot2-annotate-outside-of-plot/12417481#12417481
-->

Version with estimation and evaluation samples:
```{r, fig.height = 4.8, fig.width = 7.2}
my_xlab <- expression(paste("Density of ", italic("Clostridium difficile")))

p <- ggplot(tb.aa, aes(x = Clostridium_difficile, y = Protocol, 
        color = Calibrated, shape = Set)) +
    geom_vline(xintercept = cdiff_density, color = "grey") +
    geom_jitter(height = 0.1, width = 0) +
    scale_x_log10() +
    scale_shape_manual(breaks = c("Est", "Eval"), values = c(1, 16)) +
    annotate("text", x = cdiff_density, y = Inf, label = "True abundance",
        vjust = -0.5) +
    theme(plot.margin = margin(t = 1, unit = "lines")) +
    xlab(my_xlab)
gt <- ggplot_gtable(ggplot_build(p))
gt$layout$clip[gt$layout$name == "panel"] <- "off"
grid::grid.draw(gt)
```

## Calibration relative to the ground truth using the mock-only sample

## Calibration relative to protocol W

Estimate biases:
```{r}
taxa <- taxa_names(ps1)
ps1.clr <- ps1 %>% transform_sample_counts(clr, denom = "all")
# Calculate the median clr across individuals within a protocol
tb0 <- ps1.clr %>% as_tibble %>%
    filter(Sample %in% samples_est) %>%
    group_by(Protocol) %>%
    summarize_at(taxa, median)
# (Above here, same as for bias to truth)
# Get the biases as the diff from protocol W
tb1 <- tb0 %>%
    gather(key = "Taxon", value = "CLR", taxa) %>%
    spread(key = Protocol, value = CLR)
biases <- tb1 %>%
    mutate(H = H - W, Q = Q - W, W = W - W)
# Format for my calibration functions
bias_mat <- biases %>% select(-Taxon) %>% as("matrix")
rownames(bias_mat) <- biases$Taxon
```
Calibrate the full set of samples.
```{r}
ps1.clr.cal <- calibrate_clr(ps1.clr, "Protocol", bias_mat)
```
Distances before/after:
```{r}
d <- phyloseq::distance(ps1.clr, method = 'euclidean')
d.cal <- phyloseq::distance(ps1.clr.cal, method = 'euclidean')
tb0 <- usedist::dist_groups(d, sample_data(ps1.clr)$Protocol) %>% 
    as_tibble %>%
    mutate(Calibrated = "No")
tb1 <- usedist::dist_groups(d.cal, sample_data(ps1.clr.cal)$Protocol) %>%
    as_tibble %>%
    mutate(Calibrated = "Yes")
tb2 <- bind_rows(tb0, tb1)
tb3 <- tb2 %>%
    filter(Item1 %in% samples_eval, Item2 %in% samples_eval)
```

```{r}
ggplot(tb3, aes(Label, Distance)) +
    geom_violin(draw_quantiles = c(0.5)) + 
    geom_jitter(width=0.25) + 
    facet_wrap(~Calibrated) + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

Note that the "within" distances do not change after calibration. This is an
exact mathematical property of log-ratio based distances.
