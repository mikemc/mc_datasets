---
title: "Biases and calibration of the mock community spike-in"
output:
  html_document:
    toc: true
    toc_float: false
    code_folding: show
    self_contained: true
---

# Setup

```{r package_options, include=FALSE, cache=FALSE}
# 
knitr::opts_knit$set(progress=TRUE, verbose=TRUE)
# Global chunk options
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE, echo=TRUE, warning=FALSE,
    message=FALSE, fig.width=10, fig.height=8, include=TRUE)
# R options
options(width=100)
# options(digits=2)
```

```{r load_packages, include=T, cache=F}
library(phyloseq)
library(stringr)
library(tidyverse)
library(magrittr)

## Source bias estimation functions
devtools::load_all("~/active_research/src/metacal")

## Avoid confusing behavior from factor conversion
options(stringsAsFactors = FALSE)

```

```{r set_paths}
git_path <- file.path("~/active_research/metagenomics_calibration")
data_path <- file.path(git_path, "costea2017", "data")
metadata_path <- file.path(git_path, "costea2017", "metadata")
```

Phyloseq object with the species abundance table for Phase 3 samples:
```{r load_data}
ps <- readRDS(file.path(data_path, "phase3_phyloseq.Rds"))
```

Subset to the mock community taxa:
```{r}
mock_taxa <- c("Blautia_hansenii", "Clostridium_difficile",
    "Clostridium_perfringens", "Clostridium_saccharolyticum",
    "Fusobacterium_nucleatum", "Lactobacillus_plantarum",
    "Prevotella_melaninogenica", "Salmonella_enterica",
    "Vibrio_cholerae", "Yersinia_pseudotuberculosis")
phage <- "Salmonella_phage_Fels_1"
ps0 <- prune_taxa(mock_taxa, ps)
ps0
(sample_sums(ps0) / sample_sums(ps)) %>% sort
```

It is also useful to have a version with no zeros. For now, I will use the
somewhat crude method of adding a pseudo-abundance equal to the minimally
inferred abundance across all species and samples.
```{r}
min_ra <- ps0 %>% otu_table %>% c %>% {min(.[.>0])}
ps1 <- ps0 %>% 
    transform_sample_counts(function (x) {x <- x + min_ra; x / sum(x)})
```

Expected mock community composition:
```{r}
mdf <- readxl::read_xlsx(file.path(metadata_path,
        "composition_of_mock_community.xlsx"), sheet=1)
mdf <- mdf %>% rename(Species = `Bacterial species`) %>%
    mutate(Species = str_extract(Species, "\\S+ \\S+"),
        Species = str_replace(Species, " ", "_"))
# I'm not sure what the "ground truth" is; for now, take as
# "bacterial cells in spike in Mix"
mdf0 <- mdf %>%
    select(Species, Cell_density = "bacterial cells in spike in Mix")
# Take the average of the log density as the estimated "truth" for the species
# where there are two measurements
mock_comp <- mdf0 %>%
    mutate(Log2_density = log2(Cell_density)) %>%
    group_by(Species) %>%
    summarize(Log2_density = mean(Log2_density))
# Verify species names match
setequal(taxa_names(ps0), mock_comp$Species)
```

# Pairwise biases

Calculate the pairwise ratios for each sample:
```{r}
ratios <- otu_table(ps0) %>%
    pairwise_ratios
ratios_tb <- ratios %>%
    as_tibble(rownames = "Sample")
sam <- sample_data(ps0) %>% as_tibble
tb <- left_join(sam, ratios_tb, by = "Sample")
tb0 <- tb %>%
    gather(key = "Pair", value = "Ratio", colnames(ratios)) %>%
    mutate(Individual = ifelse(Individual == "Mock-only", "M", Individual))
```

Plot the ratios with labels corresponding to `Individual`:
```{r}
ggplot(tb0, 
    aes(x = Pair, y = log2(Ratio), color = Protocol, label = Individual)) + 
    geom_text(position = position_jitter(width=0.25, height=0)) +
    # geom_jitter(width=0.25, height=0) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

Calculate the pairwise ratios relative to the "ground truth".
```{r}
# First get an otu table with the correct relative abundances for each sample
mat <- matrix(data = rep(2**mock_comp$Log2_density, nsamples(ps0)),
    nrow = nsamples(ps0), byrow = TRUE)
rownames(mat) <- sample_names(ps0)
colnames(mat) <- mock_comp$Species
# Get the taxa in the right order:
mat <- mat[, taxa_names(ps0)]
mock_mat <- mat
# Calc ratios
mock_ratios <- pairwise_ratios(mock_mat)
all.equal(colnames(ratios), colnames(mock_ratios))
all.equal(rownames(ratios), rownames(mock_ratios))
# Ratio of ratios
ratios_to_truth <- ratios / mock_ratios
# corner(ratios_to_truth, 2, 3)
```

```{r}
sam <- sample_data(ps0) %>% as_tibble
tb <- ratios_to_truth %>%
    as_tibble(rownames = "Sample") %>%
    left_join(sam, ratios_tb, by = "Sample")
tb0 <- tb %>%
    gather(key = "Pair", value = "Ratio", colnames(ratios)) %>%
    mutate(Individual = ifelse(Individual == "Mock-only", "M", Individual))
ggplot(tb0, 
    aes(x = Pair, y = log2(Ratio), color = Protocol, label = Individual)) + 
    geom_text(position = position_jitter(width=0.25, height=0)) +
    # geom_jitter(width=0.25, height=0) +
    ylab("(Log2) Bias") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

# CLR biases

Aim is to calculate the CLR for each sample; subtract off the "truth"; and plot.
This should give a less redundant overview of how consistent bias is. In
future, may try while excluding Blautia from the denominator since it's one of
the species and has a few zero counts. For now, I'll work with the version with
zeros removed.
```{r}
observed <- otu_table(ps1) %>%
    transform_sample_counts(clr, denom = "all") %>%
    as("matrix")
expected <- otu_table(mock_mat, taxa_are_rows = FALSE) %>%
    transform_sample_counts(clr, denom = "all") %>%
    as("matrix")
clr_diff <- observed - expected
```

```{r}
tb <- clr_diff %>% as_tibble(rownames = "Sample") %>%
    left_join(sam, ., by = "Sample") %>%
    gather(key = "Taxon", value = "Bias", taxa_names(ps1)) %>%
    mutate(Individual = ifelse(Individual == "Mock-only", "M", Individual))
ggplot(tb, 
    aes(x = Taxon, y = Bias, color = Protocol, label = Individual)) + 
    geom_text(position = position_jitter(width=0.25, height=0)) +
    # geom_jitter(width=0.25, height=0) +
    ylab("(Log2) Bias") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
    # coord_cartesian(clip = "off")
```

Another way to look at this, which includes info about variation in expected
frequency:
```{r}
tb <- observed %>% as_tibble(rownames = "Sample") %>%
    left_join(sam, ., by = "Sample") %>%
    gather(key = "Taxon", value = "CLR", taxa_names(ps1)) %>%
    mutate(Individual = ifelse(Individual == "Mock-only", "M", Individual))
truth <- mock_comp %>%
    mutate(CLR = Log2_density - mean(Log2_density))
ggplot(tb, 
    aes(x = Taxon, y = CLR, color = Protocol, label = Individual)) + 
    geom_text(position = position_jitter(width=0.25, height=0)) +
    geom_point(data = truth, mapping = aes(x = Species, y = CLR),
        color = "black", shape = 3, size = 5, inherit.aes = FALSE) +
    ylab("CLR") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

# Calibration

## Calibration relative to the ground truth

First, we'll pick samples for estimation and cross validation.
```{r}
# Pick ind's for estimation and evaluatino
set.seed(1)
sam <- sample_data(ps1) %>% as_tibble
individuals_est <- base::sample(1:8, 3, replace = FALSE) %>% as.character
individuals_eval <- 1:8 %>% as.character %>% setdiff(individuals_est)
samples_est <- sam %>% 
    filter(Individual %in% individuals_est) %$%
    Sample
samples_eval <- sam %>% 
    filter(Individual %in% individuals_eval) %$%
    Sample
ps1_est <- ps1 %>% prune_samples(samples_est, .)
ps1_eval <- ps1 %>% prune_samples(samples_eval, .)
```

Estimate biases:
```{r}
taxa <- taxa_names(ps1)
ps1_est_clr <- ps1_est %>% transform_sample_counts(clr, denom = "all")
# Calculate the median clr across individuals within a protocol
tb <- ps1_est_clr %>% as_tibble
tb0 <- tb %>% group_by(Protocol) %>%
    summarize_at(taxa, median)
# Get the biases as the diff from truth
tb1 <- tb0 %>%
    gather(key = "Species", value = "CLR", taxa) %>%
    left_join(truth, by = "Species", suffix = c("", "_true")) %>%
    mutate(Bias = CLR - CLR_true)
# Format for my calibration functions
biases <- tb1 %>%
    select(Taxon = Species, Protocol, Bias) %>%
    spread(key = Protocol, value = Bias)
bias_mat <- biases %>% select(-Taxon) %>% as("matrix")
rownames(bias_mat) <- biases$Taxon
```

```{r}
ps1_eval_clr <- ps1_eval %>% transform_sample_counts(clr, denom = "all")
ps1_eval_clr_cal <- calibrate_clr(ps1_eval_clr, "Protocol", bias_mat)
```

Objects for computing distances
```{r}
# Add the truth
st_truth <- truth %>% select(CLR) %>% as("matrix") %>% t
colnames(st_truth) <- truth$Species
rownames(st_truth) <- "Truth"
st_truth <- otu_table(st_truth, taxa_are_rows = FALSE)
sam_truth <- data.frame(Protocol = "Truth", Phase = 3,
    row.names = "Truth") %>%
    sample_data
ps_truth_clr <- phyloseq(st_truth, sam_truth)
ps_clr <- merge_phyloseq(ps1_eval_clr, ps_truth_clr)
ps_cal_clr <- merge_phyloseq(ps1_eval_clr_cal, ps_truth_clr)
```

Distances before/after:
```{r}
d <- phyloseq::distance(ps_clr, method = 'euclidean')
d_cal <- phyloseq::distance(ps_cal_clr, method = 'euclidean')

tb0 <- usedist::dist_groups(d, sample_data(ps_clr)$Protocol) %>% as_tibble %>%
    mutate(Calibrated = "No")
tb1 <- usedist::dist_groups(d_cal, sample_data(ps_cal_clr)$Protocol) %>%
    as_tibble %>%
    mutate(Calibrated = "Yes")
tb2 <- bind_rows(tb0, tb1)
tb3 <- tb2 %>%
    filter(Group2 == "Truth")
```

```{r}
# ggplot(tb3, aes(Label, Distance)) +
#     geom_violin(draw_quantiles = c(0.5)) + 
#     geom_jitter(width=0.25) + 
#     facet_wrap(~Calibrated)
# ggplot(tb3, aes(Label, Distance, color = Calibrated)) +
#     geom_jitter(width=0.25)
ggplot(tb3, aes(Calibrated, Distance)) +
    geom_violin(draw_quantiles = c(0.5)) + 
    geom_jitter(width=0.25) + 
    facet_wrap(~Group1)
```

### PCA before/after


## Calibration relative to protocol W

We want a data frame with each row corresponding to a species and each column
corresponding to a protocol.
```{r}
## Get biases
# Hack: trick aldex into thinking we have counts
min_ra <- ps1_est %>% otu_table %>% as("matrix") %>% {min(.[.>0])}
ps1_est0 <- ps1_est %>% transform_sample_counts(function (x) round(x / min_ra))

bias_list <- c('H', 'Q') %>%
    map(~estimate_biases_aldex(ps1_est0, contrast = c('Protocol', ., 'W'),
            multithread = TRUE))
names(bias_list) <- c('H', 'Q')
bias_df <- bias_list %>%
    bind_rows(.id = "Protocol")
```
Get biases in a form for the `calibrate` function.
```{r}
biases <- bias_df %>%
    select(Taxon, Protocol, Bias) %>%
    mutate(Bias = 2**Bias) %>%
    spread(key = Protocol, value = Bias) %>%
    mutate(W = 1)
ps1_eval_cal <- calibrate(ps1_eval, "Protocol", biases)
```

Distances before/after:
```{r}
ps1_eval_clr <- ps1_eval %>% transform_sample_counts(clr)
ps1_eval_cal_clr <- ps1_eval_cal %>% transform_sample_counts(clr)
d <- phyloseq::distance(ps1_eval_clr, method = 'euclidean')
d_cal <- phyloseq::distance(ps1_eval_cal_clr, method = 'euclidean')

tb0 <- usedist::dist_groups(d, sample_data(ps1_eval_clr)$Protocol) %>% as_tibble %>%
    mutate(Calibrated = "No")
tb1 <- usedist::dist_groups(d_cal, sample_data(ps1_eval_cal_clr)$Protocol) %>%
    as_tibble %>%
    mutate(Calibrated = "Yes")
tb <- bind_rows(tb0, tb1)
```

```{r}
ggplot(tb, aes(Label, Distance)) +
    geom_violin(draw_quantiles = c(0.5)) + 
    geom_jitter(width=0.25) + 
    facet_wrap(~Calibrated) + 
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

Note that the "within" distances do not change after calibration. This is an
exact mathematical property of log-ratio based distances.
