---
title: "Pool bias estimates across individuals"
output:
  html_document:
    toc: true
    toc_float: false
    code_folding: hide
    self_contained: true
---

# Setup

```{r package_options, include=FALSE, cache=FALSE}
# 
knitr::opts_knit$set(progress=TRUE, verbose=TRUE)
# Global chunk options
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE, echo=TRUE, warning=FALSE,
    message=FALSE, fig.width=10, fig.height=8, include=TRUE)
# R options
options(width=100)
# options(digits=2)
```

```{r load_packages, include=T, cache=F}
library(phyloseq)
library(tidyverse)
library(magrittr)

## Source bias estimation functions
devtools::load_all("~/active_research/src/metacal")

## Avoid confusing behavior from factor conversion
options(stringsAsFactors = FALSE)
```

```{r load_data}
git_path <- file.path("~/active_research/metagenomics_calibration")
data_path <- file.path(git_path, "costea2017", "data")
ps <- readRDS(file.path(data_path, "2018-05-22_phase3_phyloseq_reads.Rds"))
ps.org <- readRDS(file.path(data_path, "phase3_phyloseq_with_tree.Rds"))
# Get rid of the samples of Individual = A or B b/c these were only extracted
# by one protocol
ps <- subset_samples(ps, !(Individual %in% c("A", "B")))
ps
ps.org <- subset_samples(ps.org, !(Individual %in% c("A", "B")))
ps.org
# Species in the mock community
mock_taxa <- c("Blautia_hansenii", "Clostridium_difficile",
    "Clostridium_perfringens", "Clostridium_saccharolyticum",
    "Fusobacterium_nucleatum", "Lactobacillus_plantarum",
    "Prevotella_melaninogenica", "Salmonella_enterica",
    "Vibrio_cholerae", "Yersinia_pseudotuberculosis")
# denom for clr
denom <- setdiff(mock_taxa, "Blautia_hansenii")
```

# Filtering

Table of the number of taxa with a given prevalence (operationally defined as
appearing in at least 10 reads; ranging from 0 to 3) within the three samples
of each Individual.
```{r}
tb <- ps %>% as_tibble
taxa <- taxa_names(ps)
tb0 <- tb %>%
    gather(key = "Taxon", value = "Reads", taxa)
tb1 <- tb0 %>% group_by(Individual, Taxon) %>%
    summarize(Prev = sum(Reads >= 10))
tb2 <- tb1 %>%
    summarize(P0 = sum(Prev==0), P1 = sum(Prev==1),
        P2 = sum(Prev==2), P3 = sum(Prev==3)) 
print(tb2)
```
Thus, for each individual there are a large number of taxa that are found by
all three protocols, and most taxa within an individual are found by all three.


We can use contamination in the mock community as a way to choose filtering
thresholds.
```{r}
ps.mock <- ps %>%
    subset_samples(Individual == "Mock-only") %>%
    filter_taxa(function (x) sum(x) > 0, prune = T)
tb.mock <- ps.mock %>% as_tibble
sample_sums(ps.mock)

# Table for plotting
st <- otu_table(ps.mock) %>% 
    transform_sample_counts(function (x) 1e6 * (x+1) / sum(x+1)) %>%
    as_tibble
tb0 <- st %>%
    gather(key = "Taxon", value = "Reads", -Sample)
```

```{r}
ggplot(tb0, aes(x = Reads)) + 
    geom_histogram() +
    scale_x_log10() +
    geom_vline(xintercept = 500) +
    facet_wrap(~Sample)
```

```{r}
# List of top taxa across samples
tb0 %>%
    filter(Reads > 500) %$%
    unique(Taxon)
tb0 %>%
    filter(Reads > 100) %>%
    arrange(Reads)
tb0 %>%
    filter(Taxon %in% c("Blautia_hansenii", "Fusobacterium_nucleatum"))
```
Seems like we should definitely keep taxa whose reads form a fraction 
`r 500/1e6` of the sample total, but below that is likely to be contamination
or misclassification.

When working within a single Individual, I'll keep all taxa that meet this
threshold by either of the three protocols.

# Get biases by pooling across Individuals

Goal is to get bias estimates for as many taxa as possible.

```{r}
# For testing
# mat <- otu_table(ps.mock) %>% as_tibble %>%
#     select(mock_taxa) %>%
#     as("matrix")
# obs1 <- mat[1,]
# obs2 <- mat[2,]

# Compute bias posterior for a single observation from each protocol
bias_post <- function (obs1, obs2, n = 128, denom = "all") {
    p1.samples <- extraDistr::rdirichlet(n, 1 + obs1)
    p2.samples <- extraDistr::rdirichlet(n, 1 + obs2)
    colnames(p1.samples) <- names(obs1)
    colnames(p2.samples) <- names(obs2)
    clr1.samples <- p1.samples %>%
        apply(1, clr, denom = denom) %>%
        t
    clr2.samples <- p2.samples %>%
        apply(1, clr, denom = denom) %>%
        t
    clr1.samples - clr2.samples
}

# Function for looping over all individuals
bias_post_ind <- function(ind, protocols, ps, n = 128) {
    # Subset
    sns <- sample_data(ps) %>% as_tibble %>%
        filter(Individual == ind, Protocol %in% protocols) %>%
        arrange(Protocol) %$%
        Sample
    st <- otu_table(ps)[sns, ]
    # Filter
    st.ra <- transform_sample_counts(st, function (x) x / sum(x))
    taxa_pass <- filter_taxa(st.ra, function (x) any(x >= (500/1e6)))
    taxa_pass[denom] <- TRUE # Make sure the mock makes it (should always)
    st.filt <- st[, taxa_pass]
    # Get posterior
    obs1 <- st.filt[1,] %>% c
    obs2 <- st.filt[2,] %>% c
    names(obs1) <- taxa_names(st.filt)
    names(obs2) <- taxa_names(st.filt)
    bias.post <- bias_post(obs1, obs2, n = n, denom = denom)
    # Tidy
    tb <- bias.post %>%
        as_tibble %>%
        add_column(Individual = ind, .before = 1) %>%
        gather(key = "Taxon", value = "Bias", -Individual)
    tb
}
```

```{r}
# Compute for each individual and them combine
individuals <- as.character(1:8)
biasHW.post <- individuals %>%
    map(bias_post_ind, c("H", "W"), ps) %>%
    bind_rows
biasQW.post <- individuals %>%
    map(bias_post_ind, c("Q", "W"), ps) %>%
    bind_rows
bias.post <- bind_rows(list(HW = biasHW.post, QW = biasQW.post), 
    .id = "Protocols")
```

Consider the variation in bias posteriors from different Individuals:
```{r}
bias.post %>%
    filter(Taxon %in% mock_taxa) %>%
    ggplot(aes(x = Taxon, y = Bias, color = Individual)) +
    # geom_violin() +
    ggthemes::geom_tufteboxplot(median.type = "line", 
        whisker.type = 'line', hoffset = 0, size = 0.9) +
    facet_wrap(~Protocols) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

To get a point estimate, we can try simply taking the mean (or median) of the
combined posteriors, weighting each Individual equally:
```{r}
bias <- bias.post %>%
    group_by(Protocols, Taxon) %>%
    summarize(Median = median(Bias), Mean = mean(Bias), SD = sd(Bias)) %>%
    mutate(Median = Median - mean(Median), Mean = Mean - mean(Mean)) %>%
    ungroup()
bias %$% cor(Median, Mean)
# TODO: Make sure the above centering calculation is doing what I want
```


## Bias trees

```{r}
library(ggtree)

bias.HW <- bias %>% filter(Protocols == "HW") %>% select(-Protocols)
bias.QW <- bias %>% filter(Protocols == "QW") %>% select(-Protocols)
tax <- tax_table(ps) %>% as_tibble

tree <- phy_tree(ps) %>% prune_taxa(bias$Taxon, .)
ttree <- tidytree::as_data_frame(tree) %>%
    left_join(bias.HW, by = c("label" = "Taxon")) %>%
    left_join(bias.QW, by = c("label" = "Taxon"), suffix = c(".HW", ".QW")) %>%
    left_join(tax, by = c("label" = "Taxon"))
td <- tidytree::as.treedata(ttree)
gt <- ggtree(td, layout = "circular")

gt + geom_tippoint(aes(fill = Mean.HW, size = log10(1/SD.HW^2)), 
    shape=21, color="black") +
    scale_fill_gradient2(low="red", mid="white", high="blue") +
    theme(legend.position='right')

gt + geom_tippoint(aes(fill = Mean.QW, size = log10(1/SD.QW^2)), 
    shape=21, color="black") +
    scale_fill_gradient2(low="red", mid="white", high="blue") +
    theme(legend.position='right')
```

```{r, fig.widgth = 8, fig.height = 10}
gt <- ggtree(td, layout = "rectangular")
gt + geom_tippoint(aes(fill = Mean.QW, size = log10(1/SD.QW^2)), 
    shape=21, color="black") +
    scale_fill_gradient2(low="red", mid="white", high="blue") +
    theme(legend.position='right')
```

here. try to label key clades / species on the tree. play with formatting.

```{r, eval = F}
gt <- ggtree(td, layout = "rectangular")

gt + geom_tippoint(aes(fill = Genus), size = 3)

gt + geom_tiplab(aes(label = Species))

# gt + geom_cladelabel(node=45, label="test label")
```


```{r, eval = F}
# library(ggtree)

tree <- phy_tree(ps) %>% prune_taxa(bias$Taxon, .)
# tax <- tax_table(ps) %>% as_tibble
# ttree <- tidytree::as_data_frame(tree) %>%
#     left_join(tax, by = c("label" = "Taxon"))
# td <- tidytree::as.treedata(ttree)
# gt <- ggtree(td, layout = "circular")
gt <- ggtree(tree, layout = "circular")

gt + geom_tiplab(aes(angle = angle))
```

### For poster

```{r, eval = F}
ggplot(bias.QW, aes(x = Median, y = SD)) + geom_jitter()
ggplot(bias.QW, aes(x = Mean, y = Median)) + geom_jitter()
# Could prune below certain SD

# Get the MRCA node for the lower half large clade
two_taxa <- tax %>% 
    filter(Genus %in% c("Bacteroides", "Bifidobacterium")) %>%
    group_by(Genus) %>%
    sample_n(1) %$%
    Taxon
```

HERE. Next, is to further prune the tree to just the taxa with bias estimates,
and to label certain clades to comment on. Might also want to remove high SD
tips.

```{r}
tree <- phy_tree(ps) %>% prune_taxa(bias.QW$Taxon, .)
mrca_node <- ape::getMRCA(tree, two_taxa)
tree0 <- ape::extract.clade(tree, mrca_node)
# Remove taxa with highly uncertain bias estimates
high_sd_taxa <- bias.QW %>%
    filter(SD > 1.2) %$%
    Taxon
tree1 <- ape::drop.tip(tree0, high_sd_taxa)

# Plot with ggtree
ttree <- tidytree::as_data_frame(tree1) %>%
    left_join(bias.QW, by = c("label" = "Taxon")) %>%
    left_join(tax, by = c("label" = "Taxon"))
td <- tidytree::as.treedata(ttree)
gt <- ggtree(td, layout = "rectangular")

g <- gt + geom_tippoint(aes(fill = Mean - mean(Mean, na.rm = T)), 
    shape=21, color="black", size = 3) +
    # scale_fill_gradient() +
    scale_fill_distiller(type = "seq", palette = 1) +
    # scale_fill_distiller(type = "div", palette = 1) +
    # scale_fill_gradient2() +
    # scale_fill_gradientn(colors = c("#d73027", "#ffffbf", "#313695")) +
    # scale_fill_gradientn(colors = c("#e41a1c", "#377eb8", "#4daf4a")) + 
    theme(legend.position='right') +
    labs(fill = "Bias")
ggsave("/tmp/bias_tree_QW.pdf", g, width = 6, height = 8, units = "in")
ggsave("/tmp/bias_tree_QW0.svg", g, width = 6, height = 8, units = "in")
ggsave("/tmp/bias_tree_QW1.svg", g, width = 6, height = 8, units = "in", scale = 4/3)
ggsave("/tmp/bias_tree_QW2.svg", g, width = 6, height = 8, units = "in",
    device = grDevices::svg)
# For some reason, needs a 4/3 scaling for the svg to come out to the correct
# size. Not sure how this affects the font size
```



## Bias versus phylogenetic distance

```{r, eval = F}
phyd <- ape::cophenetic.phylo(tree) %>% 
    as.dist(diag = FALSE, upper = FALSE) %>%
    {broom::tidy(.)} %>% 
    as_tibble %>%
    rename(Taxon1 = item1, Taxon2 = item2,
        Phy_dist = distance)
phyd0 <- phyd %>%
    left_join(select(bias.HW, Taxon1 = Taxon, Bias1 = Mean), by = "Taxon1") %>%
    left_join(select(bias.HW, Taxon2 = Taxon, Bias2 = Mean), by = "Taxon2") %>%
    mutate(Bias_dist = abs(Bias1 - Bias2))
```

```{r, eval = F}
phyd1 <- phyd0 %>%
    filter(Phy_dist < 2)
phyd1 %$% cor(Phy_dist, Bias_dist, use = "complete.obs")
ggplot(phyd1, aes(x = Phy_dist, y = Bias_dist)) +
    geom_jitter()
```

# (OLD) Bias versus phylogeny

## Get biases within each individual

For calculating biases, we want to take a log-ratio transform with the mock
taxa as the denominator. We'll exclude Blautia hansenii from the denominator
due to the presence of zero counts in several samples.
```{r}
denom <- setdiff(mock_taxa, "Blautia_hansenii")
ps.lr <- ps.org %>% 
    transform_sample_counts(clr, denom = denom)
```

Estimate biases relative to protocol W. Do so by calculating for each
Individual, and then for each taxon, take the median of the biases seen across
individuals (dropping NA's, which correspond to absence in protocol W for that
individual).
```{r}
tb <- ps.lr %>% as_tibble
# Get the biases as the diff from W
tb0 <- tb %>%
    select(Individual, Protocol, taxa) %>%
    gather(key = "Taxon", value = "LR", taxa) %>%
    spread(key = Protocol, value = "LR") %>%
    mutate(BiasHW = H - W, BiasQW = Q - W)
# NOTE: this tibble (tb0) will be useful for examining consistency
# Filter rows where biases are NA. Should only happen b/c species not found by
# Q protocol.
tb1 <- tb0 %>% filter(!(is.na(BiasHW) | is.na(BiasQW)))
biases <- tb1 %>%
    group_by(Taxon) %>%
    summarize(BiasHW = median(BiasHW, na.rm=TRUE), 
        BiasQW = median(BiasQW, na.rm=TRUE))
```

```{r}
```

Is bias consistent across individuals?


## Difference in bias versus phylogenetic distance

```{r}
tree <- phy_tree(ps.lr) %>% prune_taxa(biases$Taxon, .)
phyd <- ape::cophenetic.phylo(tree) %>% 
    as.dist(diag = FALSE, upper = FALSE) %>%
    {broom::tidy(.)} %>% 
    as_tibble %>%
    rename(Taxon1 = item1, Taxon2 = item2,
        Phy_dist = distance)
# summary(phyd$distance)
# bias_vector <- biases$BiasHW
# names(bias_vector) <- biases$Taxon
# bd <- dist(bias_vector, diag = TRUE, upper = TRUE) %>%
#     {broom::tidy(.)} %>% 
#     as_tibble
phyd0 <- phyd %>%
    left_join(select(biases, Taxon1 = Taxon, Bias1 = BiasHW), by = "Taxon1") %>%
    left_join(select(biases, Taxon2 = Taxon, Bias2 = BiasHW), by = "Taxon2") %>%
    mutate(Bias_dist = abs(Bias1 - Bias2))
```

```{r}
phyd1 <- phyd0 %>%
    filter(Phy_dist < 2)
ggplot(phyd1, aes(x = Phy_dist, y = Bias_dist)) +
    geom_jitter()
```

__TODO:__ redo this with bounded biases

Other things could ask:
* are most closely related pairs more similar bias-wise than random pairs.
<!--  -->

## Bias trees

```{r}
library(ggtree)

tree <- phy_tree(ps.lr) %>% prune_taxa(biases$Taxon, .)
biases <- biases %>%
    mutate(bBiasHW = bound(BiasHW), bBiasQW = bound(BiasQW))
ttree <- tidytree::as_data_frame(tree) %>%
    left_join(rename(biases, label = Taxon), by = "label")

# This fails; possibly a bug
# ttree0 <- ttree %>%
#     mutate(bBiasHW = bound(BiasHW), bBiasQW = bound(BiasQW))
# td <- as.treedata(ttree0)
```

```{r, eval=F}
qplot(biases$BiasHW)
```

```{r}
td <- tidytree::as.treedata(ttree)
gt <- ggtree(td, layout = "circular")

med <- median(ttree$bBiasHW, na.rm=TRUE)
gt + geom_tippoint(aes(fill = bBiasHW), shape=21, color="black", size = 3.5) +
    scale_fill_gradient2(midpoint = med, 
        low="red", mid="white", high="blue") +
    theme(legend.position='right')

med <- median(ttree$bBiasQW, na.rm=TRUE)
gt + geom_tippoint(aes(fill = bBiasQW), shape=21, color="black", size = 3.5) +
    scale_fill_gradient2(midpoint = med, 
        low="red", mid="white", high="blue") +
    theme(legend.position='right')
```

### Investigating outliers

Let's look at just Bacteroides.
```{r, eval=F}
# ttree0 <- ttree %>%
#     full_join(tax_table(ps.lr) %>% as_tibble %>% rename(label = Taxon), by = "label")
bacteroides_species <- taxa_names(ps.lr) %>%
    str_subset("Bacteroides.*")
ps0 <- prune_taxa(bacteroides_species, ps.lr)
tree <- phy_tree(ps0) %>% prune_taxa(biases$Taxon, .)
biases <- biases %>%
    mutate(bBiasHW = bound(BiasHW), bBiasQW = bound(BiasQW))
ttree <- tidytree::as_data_frame(tree) %>%
    left_join(rename(biases, label = Taxon), by = "label")
td <- as.treedata(ttree)
gt <- ggtree(td, layout = "rectangular")
med <- median(ttree$bBiasHW, na.rm=TRUE)
gt + geom_tippoint(aes(fill = bBiasHW), shape=21, color="black", size = 3.5) +
    scale_fill_gradient2(midpoint = med, 
        low="red", mid="white", high="blue") + geom_tiplab() + 
    theme(legend.position = 'right')
# The outlier is a case of a negative infinite bias result that was set to the
# lower bound. `Bacteroides_plebeius`
biases %>% filter(Taxon %in% bacteroides_species) %>% print(n = 24)
# 16 Bacteroides_plebeius         -Inf       2.68   -4.98    2.68
tb1 %>% filter(Taxon %in% "Bacteroides_plebeius")
```
From this, we can see that the inference of a negative bias is probably
incorrect. In the two cases where it was found by protocol H, the bias was in
fact positive. But since detection was less likely in H, than W, we end up with
more `-Inf`'s which lead to a median of `-Inf`.
