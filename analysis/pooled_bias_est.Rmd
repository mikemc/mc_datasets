---
title: "Pool bias estimates across individuals"
output:
  html_document:
    toc: true
    toc_float: false
    code_folding: hide
    self_contained: true
---

# Setup

```{r package_options, include=FALSE, cache=FALSE}
# 
knitr::opts_knit$set(progress=TRUE, verbose=TRUE)
# Global chunk options
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE, echo=TRUE, warning=FALSE,
    message=FALSE, fig.width=10, fig.height=8, include=TRUE)
# R options
options(width=100)
# options(digits=2)
```

```{r load_packages, include=T, cache=F}
library(phyloseq)
library(tidyverse)
library(magrittr)
library(ggtree)
library(ggthemes)

## Source bias estimation functions
devtools::load_all("~/active_research/src/metacal")

## Avoid confusing behavior from factor conversion
options(stringsAsFactors = FALSE)
```

```{r load_data}
git_path <- file.path("~/active_research/metagenomics_calibration")
data_path <- file.path(git_path, "costea2017", "data")
ps <- readRDS(file.path(data_path, "2018-05-22_phase3_phyloseq_reads.Rds"))
ps.org <- readRDS(file.path(data_path, "phase3_phyloseq_with_tree.Rds"))
# Get rid of the samples of Individual = A or B b/c these were only extracted
# by one protocol
ps <- subset_samples(ps, !(Individual %in% c("A", "B")))
ps
ps.org <- subset_samples(ps.org, !(Individual %in% c("A", "B")))
ps.org
# Species in the mock community
mock_taxa <- c("Blautia_hansenii", "Clostridium_difficile",
    "Clostridium_perfringens", "Clostridium_saccharolyticum",
    "Fusobacterium_nucleatum", "Lactobacillus_plantarum",
    "Prevotella_melaninogenica", "Salmonella_enterica",
    "Vibrio_cholerae", "Yersinia_pseudotuberculosis")
# denom for clr
denom <- setdiff(mock_taxa, "Blautia_hansenii")
```

# Filtering

Table of the number of taxa with a given prevalence (operationally defined as
appearing in at least 10 reads; ranging from 0 to 3) within the three samples
of each Individual.
```{r}
tb <- ps %>% as_tibble
taxa <- taxa_names(ps)
tb0 <- tb %>%
    gather(key = "Taxon", value = "Reads", taxa)
tb1 <- tb0 %>% group_by(Individual, Taxon) %>%
    summarize(Prev = sum(Reads >= 10))
tb2 <- tb1 %>%
    summarize(P0 = sum(Prev==0), P1 = sum(Prev==1),
        P2 = sum(Prev==2), P3 = sum(Prev==3)) 
print(tb2)
```
Thus, for each individual there are a large number of taxa that are found by
all three protocols, and most taxa within an individual are found by all three.


We can use contamination in the mock community as a way to choose filtering
thresholds.
```{r}
ps.mock <- ps %>%
    subset_samples(Individual == "Mock-only") %>%
    filter_taxa(function (x) sum(x) > 0, prune = T)
tb.mock <- ps.mock %>% as_tibble
sample_sums(ps.mock)

# Table for plotting
st <- otu_table(ps.mock) %>% 
    transform_sample_counts(function (x) 1e6 * (x+1) / sum(x+1)) %>%
    as_tibble
tb0 <- st %>%
    gather(key = "Taxon", value = "Reads", -Sample)
```

```{r}
ggplot(tb0, aes(x = Reads)) + 
    geom_histogram() +
    scale_x_log10() +
    geom_vline(xintercept = 500) +
    facet_wrap(~Sample)
```

```{r}
# List of top taxa across samples
tb0 %>%
    filter(Reads > 500) %$%
    unique(Taxon)
tb0 %>%
    filter(Reads > 100) %>%
    arrange(Reads)
tb0 %>%
    filter(Taxon %in% c("Blautia_hansenii", "Fusobacterium_nucleatum"))
```
Seems like we should definitely keep taxa whose reads form a fraction 
`r 500/1e6` of the sample total, but below that is likely to be contamination
or misclassification.

When working within a single Individual, I'll keep all taxa that meet this
threshold by either of the three protocols.

# Get biases by pooling across Individuals

Goal is to get bias estimates for as many taxa as possible.

```{r}
# For testing
# mat <- otu_table(ps.mock) %>% as_tibble %>%
#     select(mock_taxa) %>%
#     as("matrix")
# obs1 <- mat[1,]
# obs2 <- mat[2,]

# Compute bias posterior for a single observation from each protocol
bias_post <- function (obs1, obs2, n = 128, denom = "all") {
    p1.samples <- extraDistr::rdirichlet(n, 1 + obs1)
    p2.samples <- extraDistr::rdirichlet(n, 1 + obs2)
    colnames(p1.samples) <- names(obs1)
    colnames(p2.samples) <- names(obs2)
    clr1.samples <- p1.samples %>%
        apply(1, clr, denom = denom) %>%
        t
    clr2.samples <- p2.samples %>%
        apply(1, clr, denom = denom) %>%
        t
    clr1.samples - clr2.samples
}

# Function for looping over all individuals
bias_post_ind <- function(ind, protocols, ps, n = 128) {
    # Subset
    sns <- sample_data(ps) %>% as_tibble %>%
        filter(Individual == ind, Protocol %in% protocols) %>%
        arrange(Protocol) %$%
        Sample
    st <- otu_table(ps)[sns, ]
    # Filter
    st.ra <- transform_sample_counts(st, function (x) x / sum(x))
    taxa_pass <- filter_taxa(st.ra, function (x) any(x >= (500/1e6)))
    taxa_pass[denom] <- TRUE # Make sure the mock makes it (should always)
    st.filt <- st[, taxa_pass]
    # Get posterior
    obs1 <- st.filt[1,] %>% c
    obs2 <- st.filt[2,] %>% c
    names(obs1) <- taxa_names(st.filt)
    names(obs2) <- taxa_names(st.filt)
    bias.post <- bias_post(obs1, obs2, n = n, denom = denom)
    # Tidy
    tb <- bias.post %>%
        as_tibble %>%
        add_column(Individual = ind, .before = 1) %>%
        gather(key = "Taxon", value = "Bias", -Individual)
    tb
}
```

```{r}
# Compute for each individual and them combine
individuals <- as.character(1:8)
biasHW.post <- individuals %>%
    map(bias_post_ind, c("H", "W"), ps) %>%
    bind_rows
biasQW.post <- individuals %>%
    map(bias_post_ind, c("Q", "W"), ps) %>%
    bind_rows
bias.post <- bind_rows(list(HW = biasHW.post, QW = biasQW.post), 
    .id = "Protocols")
```

Consider the variation in bias posteriors from different Individuals:
```{r}
bias.post %>%
    filter(Taxon %in% mock_taxa) %>%
    ggplot(aes(x = Taxon, y = Bias, color = Individual)) +
    # geom_violin() +
    ggthemes::geom_tufteboxplot(median.type = "line", 
        whisker.type = 'line', hoffset = 0, size = 0.9) +
    facet_wrap(~Protocols) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

To get a point estimate, we can try simply taking the mean (or median) of the
combined posteriors, weighting each Individual equally:
```{r}
bias <- bias.post %>%
    group_by(Protocols, Taxon) %>%
    summarize(Median = median(Bias), Mean = mean(Bias), SD = sd(Bias)) %>%
    mutate(Median = Median - mean(Median), Mean = Mean - mean(Mean)) %>%
    ungroup()
bias %$% cor(Median, Mean)
# TODO: Make sure the above centering calculation is doing what I want
```


## Bias trees

```{r}
bias.HW <- bias %>% filter(Protocols == "HW") %>% select(-Protocols)
bias.QW <- bias %>% filter(Protocols == "QW") %>% select(-Protocols)
tax <- tax_table(ps) %>% as_tibble

tree <- phy_tree(ps) %>% prune_taxa(bias$Taxon, .)
ttree <- tidytree::as_data_frame(tree) %>%
    left_join(bias.HW, by = c("label" = "Taxon")) %>%
    left_join(bias.QW, by = c("label" = "Taxon"), suffix = c(".HW", ".QW")) %>%
    left_join(tax, by = c("label" = "Taxon"))
td <- tidytree::as.treedata(ttree)
gt <- ggtree(td, layout = "circular")

gt + geom_tippoint(aes(fill = Mean.HW, size = log10(1/SD.HW^2)), 
    shape=21, color="black") +
    scale_fill_gradient2(low="red", mid="white", high="blue") +
    theme(legend.position='right')

gt + geom_tippoint(aes(fill = Mean.QW, size = log10(1/SD.QW^2)), 
    shape=21, color="black") +
    scale_fill_gradient2(low="red", mid="white", high="blue") +
    theme(legend.position='right')
```

```{r, fig.widgth = 8, fig.height = 10}
gt <- ggtree(td, layout = "rectangular")
gt + geom_tippoint(aes(fill = Mean.QW, size = log10(1/SD.QW^2)), 
    shape=21, color="black") +
    scale_fill_gradient2(low="red", mid="white", high="blue") +
    theme(legend.position='right')
```

here. try to label key clades / species on the tree. play with formatting.

```{r, eval = F}
gt <- ggtree(td, layout = "rectangular")

gt + geom_tippoint(aes(fill = Genus), size = 3)

gt + geom_tiplab(aes(label = Species))

# gt + geom_cladelabel(node=45, label="test label")
```


```{r, eval = F}
# library(ggtree)

tree <- phy_tree(ps) %>% prune_taxa(bias$Taxon, .)
# tax <- tax_table(ps) %>% as_tibble
# ttree <- tidytree::as_data_frame(tree) %>%
#     left_join(tax, by = c("label" = "Taxon"))
# td <- tidytree::as.treedata(ttree)
# gt <- ggtree(td, layout = "circular")
gt <- ggtree(tree, layout = "circular")

gt + geom_tiplab(aes(angle = angle))
```

### For poster

```{r, eval = F}
ggplot(bias.QW, aes(x = Median, y = SD)) + geom_jitter()
ggplot(bias.QW, aes(x = Mean, y = Median)) + geom_jitter()
# Could prune below certain SD

# Get the MRCA node for the lower half large clade
two_taxa <- tax %>% 
    filter(Genus %in% c("Bacteroides", "Bifidobacterium")) %>%
    group_by(Genus) %>%
    sample_n(1) %$%
    Taxon
```

HERE. Next, is to further prune the tree to just the taxa with bias estimates,
and to label certain clades to comment on. Might also want to remove high SD
tips.

```{r}
tree <- phy_tree(ps) %>% prune_taxa(bias.QW$Taxon, .)
mrca_node <- ape::getMRCA(tree, two_taxa)
tree0 <- ape::extract.clade(tree, mrca_node)
# Remove taxa with highly uncertain bias estimates
high_sd_taxa <- bias.QW %>%
    filter(SD > 1.2) %$%
    Taxon
tree1 <- ape::drop.tip(tree0, high_sd_taxa)

# Plot with ggtree
ttree <- tidytree::as_data_frame(tree1) %>%
    left_join(bias.QW, by = c("label" = "Taxon")) %>%
    left_join(tax, by = c("label" = "Taxon"))
td <- tidytree::as.treedata(ttree)
gt <- ggtree(td, layout = "rectangular")

g <- gt + geom_tippoint(aes(fill = Mean - mean(Mean, na.rm = T)), 
    shape=21, color="black", size = 3) +
    # scale_fill_gradient() +
    scale_fill_distiller(type = "seq", palette = 1) +
    # scale_fill_distiller(type = "div", palette = 1) +
    # scale_fill_gradient2() +
    # scale_fill_gradientn(colors = c("#d73027", "#ffffbf", "#313695")) +
    # scale_fill_gradientn(colors = c("#e41a1c", "#377eb8", "#4daf4a")) + 
    theme(legend.position='right') +
    labs(fill = "Bias")
ggsave("/tmp/bias_tree_QW.pdf", g, width = 6, height = 8, units = "in")
ggsave("/tmp/bias_tree_QW0.svg", g, width = 6, height = 8, units = "in")
ggsave("/tmp/bias_tree_QW1.svg", g, width = 6, height = 8, units = "in", scale = 4/3)
ggsave("/tmp/bias_tree_QW2.svg", g, width = 6, height = 8, units = "in",
    device = grDevices::svg)
# For some reason, needs a 4/3 scaling for the svg to come out to the correct
# size. Not sure how this affects the font size
```



## Bias versus phylogenetic distance

```{r, eval = F}
phyd <- ape::cophenetic.phylo(tree) %>% 
    as.dist(diag = FALSE, upper = FALSE) %>%
    {broom::tidy(.)} %>% 
    as_tibble %>%
    rename(Taxon1 = item1, Taxon2 = item2,
        Phy_dist = distance)
phyd0 <- phyd %>%
    left_join(select(bias.HW, Taxon1 = Taxon, Bias1 = Mean), by = "Taxon1") %>%
    left_join(select(bias.HW, Taxon2 = Taxon, Bias2 = Mean), by = "Taxon2") %>%
    mutate(Bias_dist = abs(Bias1 - Bias2))
```

```{r, eval = F}
phyd1 <- phyd0 %>%
    filter(Phy_dist < 2)
phyd1 %$% cor(Phy_dist, Bias_dist, use = "complete.obs")
ggplot(phyd1, aes(x = Phy_dist, y = Bias_dist)) +
    geom_jitter()
```

# Pooled bias estimation with Stan

## Estimate biases for protocols Q:W

```{r}
## Load data
git_path <- file.path("~/active_research/metagenomics_calibration")
data_path <- file.path(git_path, "costea2017", "data")
ps <- readRDS(file.path(data_path, "2018-05-22_phase3_phyloseq_reads.Rds")) %>%
    subset_samples(Protocol %in% c("Q", "W")) %>%
    subset_samples(Individual %in% as.character(1:8))
ps.ra <- readRDS(file.path(data_path, "phase3_phyloseq_with_tree.Rds")) %>%
    subset_samples(Protocol %in% c("Q", "W")) %>%
    subset_samples(Individual %in% as.character(1:8)) %>%
    transform_sample_counts(function (x) x / sum(x))
setequal(taxa_names(ps), taxa_names(ps.ra))
mock_taxa <- c("Blautia_hansenii", "Clostridium_difficile",
    "Clostridium_perfringens", "Clostridium_saccharolyticum",
    "Fusobacterium_nucleatum", "Lactobacillus_plantarum",
    "Prevotella_melaninogenica", "Salmonella_enterica",
    "Vibrio_cholerae", "Yersinia_pseudotuberculosis")
```

Select taxa to use based on relative abundances. For now, be stringent to speed
up run times.
```{r}
filter_taxa(ps.ra, function(x) max(x) > 1e-3) %>% sum
to_keep <- filter_taxa(ps.ra, function(x) max(x) > 1e-3)
ps0 <- prune_taxa(to_keep, ps)
all(mock_taxa %in% taxa_names(ps0))
```

Or filter based on the normalized of reads being above the threshold
I identified.
```{r}
ps.normed <- transform_sample_counts(ps, function (x) x / sum(x) * 1e6)
filter_taxa(ps.normed, function(x) max(x) > 500) %>% sum
```

Alternatively, filter to the subtree I used in my poster, plus the mock
community.
```{r}
# MRCA node for the lower half:
tax <- tax_table(ps) %>% as_tibble
two_taxa <- tax %>% 
    filter(Genus %in% c("Bacteroides", "Bifidobacterium")) %>%
    group_by(Genus) %>%
    sample_n(1) %$%
    Taxon
tree <- phy_tree(ps)
mrca_node <- ape::getMRCA(tree, two_taxa)
taxa <- tree %>%
    ape::extract.clade(mrca_node) %$%
    tip.label
# See which are also minimally frequent
to_keep <- filter_taxa(ps.ra, function(x) max(x) > 1e-3)
taxa_freq <- names(to_keep)[to_keep]
intersect(taxa, taxa_freq) %>% length
# Seems like a reasonable amount.
taxa <- intersect(taxa, taxa_freq) %>%
    union(mock_taxa)
ps1 <- prune_taxa(intersect(taxa, taxa_freq), ps)
```

```{r, eval = F}
## get observed count tables
sam <- sample_data(ps0) %>% as_tibble %>%
    arrange(Protocol, Individual) %>%
    select(-Run_accession)
tb <- sam %>%
    spread(key = Protocol, value = Sample)
st <- otu_table(ps0)
observed_tar <- st[tb$Q,]
observed_ref <- st[tb$W,]
## fit model
dat <- list(K = ntaxa(ps0),
    N = nrow(observed_tar),
    observed_tar = observed_tar,
    observed_ref = observed_ref,
    pscale_alpha = 5000,
    pscale_sigma = 5)
start.time <- Sys.time()
fit <- stan(file = file.path(stan_path, "dirmult_diff_costea.stan"),
        data = dat, iter = 2000, chains = 4)
stop.time <- Sys.time()
saveRDS(fit, file.path(data_path, prepend_date("bias_stan.Rds")))
```

```{r}
fit <- readRDS(fit, file.path(data_path, prepend_date("bias_stan.Rds")))
# precis(fit, depth = 1)
# stan_plot(fit, pars = c("true_freqs"))
# stan_plot(fit, pars = c("diff_log_bias"))
# stan_dens(fit, pars = c("diff_log_bias"))

# tb.p <- precis(fit, pars = c("diff_log_bias"), depth = 2)@output %>%
#     as_tibble %>%
#     add_column(Taxon = colnames(observed_tar), .before=1)
# print(tb.p)
```

## Visualize on tree

How to make a tree with bias posterior intervals lined up with the tips. There
are ways I can see doing this. First,

#. Get the data frame stan_plot
#. Change the y value to that in the ggtree object
#. Shift all the x values by the need offset
#. plot the layers from the stan_plot onto the ggtree
<!--  -->

Second would be to use the posterior and pass the data to a vertical boxplot
geom.


TODO: scale down the bias numbers to take a smaller range

```{r, eval = F}
# Get the tree
gt <- phy_tree(ps0) %>% ggtree(layout = "rectangular")
# create a data frame for plotting biases
p <- stan_plot(fit, pars = c("diff_log_bias"))
td <- p$data %>%
    as_tibble %>%
    add_column(taxa = taxa_names(ps0), .before = 1) %>%
    select(-params, -y)
# Offset and scale the bias values
x_scale <- 2/5
x_offset <- 8
f <- function (x) {x * x_scale + x_offset}
td <- td %>%
    mutate_at(2:7, f)
# Plot the tree with biases
g <- gt %<+% td + 
    geom_segment(aes(x = x, xend = Inf, y = y, yend = y),
        data = filter(gt$data, isTip),
        linetype = "dotted") +
    p$layers
```

```{r}
gt <- phy_tree(ps0) %>% ggtree(layout = "rectangular")
p <- stan_plot(fit, pars = c("diff_log_bias"))
td <- p$data %>%
    as_tibble %>%
    add_column(taxa = taxa_names(ps0), .before = 1) %>%
    select(-params, -y)
gt0 <- gt %<+% td 
gt1 <- gt0 + 
    geom_tiplab(align = TRUE, linetype = "dotted", linesize = 0.3, color = "black") + 
    xlim(0, 6.9)
p0 <- ggplot(data = filter(gt0$data, isTip), 
    mapping = aes(x = m, y = y, yend = y)) + 
    geom_hline(aes(yintercept = y), size = 0.3, 
        color = "black", linetype = "dotted") +
    geom_segment(aes(x = ll, xend = hh), 
        size = 0.6) + 
    geom_segment(aes(x = l, xend = h),
        size = 1.5, color = "#e41a1c") + 
    geom_point(aes(x = m, y = y), size = 2) + 
    theme_classic() +
    theme(axis.line.y = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
    xlab("(Log2) Bias")

gtab <- egg::ggarrange(plots = list(gt1, p0), nrow = 1, clip = "on", widths = c(2, 1))
```

Do this with the subtree that includes the mock and the ASM poster clades.
```{r}
gt <- phy_tree(ps1) %>% ggtree(layout = "rectangular")
p <- stan_plot(fit, pars = c("diff_log_bias"))
td <- p$data %>%
    as_tibble %>%
    add_column(taxa = taxa_names(ps0), .before = 1) %>%
    select(-params, -y)
gt0 <- gt %<+% td 
gt1 <- gt0 + 
    geom_tiplab(align = TRUE, linetype = "dotted", linesize = 0.3, color = "black") + 
    xlim(0, 6.9)
p0 <- ggplot(data = filter(gt0$data, isTip), 
    mapping = aes(x = m, y = y, yend = y)) + 
    geom_hline(aes(yintercept = y), size = 0.3, 
        color = "black", linetype = "dotted") +
    geom_segment(aes(x = ll, xend = hh), 
        size = 0.6) + 
    geom_segment(aes(x = l, xend = h),
        size = 1.5, color = "#e41a1c") + 
    geom_point(aes(x = m, y = y), size = 2) + 
    theme_classic() +
    theme(axis.line.y = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
    xlab("(Log2) Bias")

gtab0 <- egg::ggarrange(plots = list(gt0, p0), nrow = 1, clip = "on", widths = c(2, 1))
gtab1 <- egg::ggarrange(plots = list(gt1, p0), nrow = 1, clip = "on", widths = c(2, 1))

```

