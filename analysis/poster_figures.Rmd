---
title: "NC Microbiome poster figures"
output:
  html_document:
    toc: true
    toc_float: false
    code_folding: hide
    self_contained: true
---

# Setup

```{r package_options, include=FALSE, cache=FALSE}
knitr::opts_knit$set(progress=TRUE, verbose=TRUE)
# Global chunk options
knitr::opts_chunk$set(cache=TRUE, autodep=TRUE, echo=TRUE, warning=FALSE,
    message=FALSE, fig.width=8, fig.height=6, include=TRUE)
# R options
options(width=100)
# options(digits=2)
```

```{r load_packages, include=T}
# Use dev mode for latest version of ggplot
devtools::dev_mode(on = TRUE)
library(phyloseq)
library(tidyverse)
library(magrittr)

## Source bias estimation functions
devtools::load_all("~/active_research/src/metacal")

## Avoid confusing behavior from factor conversion
options(stringsAsFactors = FALSE)
```

# Brooks et al 2015 

```{r}
# Use dev mode for latest version of ggplot
devtools::dev_mode(on = TRUE)
library(phyloseq)
library(tidyverse)
library(magrittr)

## Source bias estimation functions
devtools::load_all("~/active_research/src/metacal")

## Avoid confusing behavior from factor conversion
options(stringsAsFactors = FALSE)

# Paths
data_path <- "~/data/vcu_bias"
git_path <- "~/active_research/metagenomics_calibration"
# metadata_path <- file.path(git_path, "vcu_bias", "metadata")

# Load ps object
ps <- readRDS(file.path(git_path, "vcu_bias", "brooks_results", "brooks_phyloseq.Rds"))
taxa <- taxa_names(ps)
```

```{r}
# Calculate the pairwise-biases for each sample.
st <- ps %>% otu_table %>% as_tibble
sam <- ps %>% sample_data %>% as_tibble

## Get the expected log ratios
expected_freqs <- sam %>% select(taxa) %>% as('matrix')
row.names(expected_freqs) <- sam$Sample
expected_ratios <- expected_freqs %>% 
    pairwise_ratios
# Either 0, 1, Inf, or NaN
# table(expected_ratios, exclude = c())
## Get the observed log ratios
observed_counts <- ps %>% otu_table %>% as('matrix')
observed_ratios <- observed_counts %>% pairwise_ratios
## Calculate the biases
biases <- log2(observed_ratios / expected_ratios)
# Exclude cases where taxa are absent in the design
biases[expected_ratios %in% c(0, Inf, NaN)] <- NA
## Save as a tibble
biases <- as_tibble(biases, rownames = "Sample")
# Prep for plotting
taxa_pairs <- select(biases, - Sample) %>% names
tb <- left_join(biases, select(sam, Sample:Num_species), 
    by = "Sample")
tb <- tb %>%
    gather(key = "Pair", value = "Bias", taxa_pairs) %>%
    mutate(Type = switchv(Experiment,
            Extraction = "Cells",
            PCR = "Extracted DNA",
            Seq = "PCR product")) %>%
    filter(!is.na(Bias))
```

Because the study design involved different mixtures, I think it makes the most
sense to show pairwise biases here. The mixtures were always even and so the
expected ratio was always 1 (shown as the grey line). The color of the point
denotes the number of species in the mixture and thus the expected frequency of
each species (1 / number) in the mixture. One nice thing about this figure is
it helps illustrate the point that bias arises from different steps
(extraction, PCR, and sequencing + bioinformatics).
```{r, fig.height = 8, fig.width = 10}
ggplot(tb, aes(x = Pair, y = 2^Bias, color = as.factor(Num_species))) +
    modelr::geom_ref_line(h = 1, size = 0.5, colour="grey") +
    geom_jitter(width=0.25, height=0) + facet_grid(Type ~ .) +
    labs(y = "Ratio", color = "No. species\nin mixture") +
    # labs(y = "Ratio", color = "Species\nin mixture") +
    scale_y_log10() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

# Costea et al 2017 (shotgun data)

```{r set_paths}
git_path <- file.path("~/active_research/metagenomics_calibration")
data_path <- file.path(git_path, "costea2017", "data")
metadata_path <- file.path(git_path, "costea2017", "metadata")
```

Phyloseq object with the species abundance table for Phase 3 samples:
```{r load_data}
ps <- readRDS(file.path(data_path, "phase3_phyloseq_with_tree.Rds"))
sample_data(ps) <- sample_data(ps) %>% 
sample_data(ps) %>% 
    subset(select = -Lab) %>%
    within(Individual <- ifelse(Individual == "Mock-only", "M", Individual))
# Optionally, remove the extra two samples for the Q protocol
ps <- subset_samples(ps, !(Individual %in% c("A", "B")))
ps
```
We are going to subset to the mock taxa only. There are a few zero counts in
the rare taxon `Blautia_hansenii`. To deal with these I will add pseudocounts
to each taxon, equal to the minimal observed abundance in that sample.
```{r}
ps_nonzero <- ps %>% 
    transform_sample_counts(
        function (x) {
            min_nonzero <- min(x[x>0])
            x <- x + min_nonzero
            x / sum(x)
        })
```
Now we subset to the mock community taxa:
```{r}
mock_taxa <- c("Blautia_hansenii", "Clostridium_difficile",
    "Clostridium_perfringens", "Clostridium_saccharolyticum",
    "Fusobacterium_nucleatum", "Lactobacillus_plantarum",
    "Prevotella_melaninogenica", "Salmonella_enterica",
    "Vibrio_cholerae", "Yersinia_pseudotuberculosis")
phage <- "Salmonella_phage_Fels_1"
ps0 <- prune_taxa(mock_taxa, ps)
ps0
(sample_sums(ps0) / sample_sums(ps)) %>% sort
# And a version with no zeros:
ps1 <- prune_taxa(mock_taxa, ps_nonzero)
```
Note the large variation in the proportion of the sample made up by the
spike-in.

Expected mock community composition:
```{r}
mdf <- readxl::read_xlsx(file.path(metadata_path,
        "composition_of_mock_community.xlsx"), sheet=1)
mdf <- mdf %>% rename(Taxon = `Bacterial species`) %>%
    mutate(Taxon = str_extract(Taxon, "\\S+ \\S+"),
        Taxon = str_replace(Taxon, " ", "_"))
# I'm not sure what the "ground truth" is; for now, take as
# "bacterial cells in spike in Mix"
mdf0 <- mdf %>%
    select(Taxon, Cell_density = "bacterial cells in spike in Mix")
# Take the average of the log density as the estimated "truth" for the species
# where there are two measurements
mock_comp <- mdf0 %>%
    mutate(Log2_density = log2(Cell_density)) %>%
    group_by(Taxon) %>%
    summarize(Log2_density = mean(Log2_density))
# Compute the CLR
mock_comp <- mock_comp %>%
    mutate(CLR = Log2_density - mean(Log2_density))
# Verify species names match
setequal(taxa_names(ps0), mock_comp$Taxon)
# Phyloseq object with the truth
st.truth <- mock_comp %>% select(CLR) %>% as("matrix") %>% t
colnames(st.truth) <- mock_comp$Taxon
rownames(st.truth) <- "Truth"
st.truth <- otu_table(st.truth, taxa_are_rows = FALSE)
sam.truth <- data.frame(Protocol = "Truth", Phase = 3, row.names = "Truth") %>%
    sample_data
ps.truth.clr <- phyloseq(st.truth, sam.truth)
```


## Exploration

NOTE: I have versions of these first two figures with before/after calibration
that I would maybe just use instead. Also, here the points are labeled by the
Individual from which the fecal sample came from that the spike-in was added
to, with "M" being the spike-in by itself. The point is to show bias is
consistent across different background compositions and substrates, but for the
poster I would probably just use unlabeled dots for simplicity.

PCA (euclidean centered log ratio), with the cross marking the "ground truth".
```{r, fig.height = 6, fig.width = 8}
ps1.clr <- ps1 %>% transform_sample_counts(clr, denom = "all")
p <- merge_phyloseq(ps1.clr, ps.truth.clr) %>%
    plot_pca
pd <- p$data %>%
    filter(Sample != "Truth")
truth <- p$data %>% 
    filter(Sample == "Truth")
ggplot(pd, aes(x = PC1, y = PC2, 
        color = Protocol, label = Individual)) +
    geom_text() +
    geom_point(data = truth, 
        aes(PC1, PC2),
        shape = 3, size = 4, inherit.aes = FALSE) + 
    labs(p$labels[1:2]) + 
    theme(axis.text.x = element_blank(), 
        axis.text.y = element_blank(),
        axis.ticks = element_blank())
```

Plot of species' abundance (as ratios centered on geometric mean) along with
the expected values, as in Costea2017 figure 6:
```{r, fig.height = 6, fig.width = 8}
# Order by expected abundance
species_ordered <- mock_comp %>%
    arrange(desc(CLR)) %$%
    Taxon
tb.clr <- ps1.clr %>% as_tibble %>%
    gather(key = "Taxon", value = "CLR", taxa_names(ps1.clr)) %>%
    mutate(Taxon = factor(Taxon, species_ordered))
# Points for step function of true abundances
lvls <- tb.clr$Taxon %>% levels
tb.step <- tibble(x = seq(0.5, 10.5, by = 0.5)) %>%
    mutate(x_int = pmin(floor(x + 0.5), 10),
        Taxon = lvls[x_int]) %>%
    left_join(mock_comp, by = "Taxon")
# The plot! note, doesn't work if I plot the geom_step before the text/points
ggplot(tb.clr, aes(x = Taxon, y = 2^CLR)) + 
    # geom_jitter(aes(x = Taxon, y = 2^CLR)) +
    geom_text(aes(x = Taxon, y = 2^CLR, color = Protocol, label = Individual), 
        position = position_jitter(width=0.25, height=0)) +
    geom_step(data = tb.step, aes(x = x, y = 2^CLR), alpha=0.3) +
    ylab("Abundance / geometric mean") +
    scale_y_log10(limits = c(1e-3, 1e2)) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

Phylogeny; might be useful to include for illustration purposes despite lack of
sufficient phylogenetic resolution to say much. For example, the clade of
*Vibrio*, *Salmonella*, and *Yersinia* have a similar bias pattern across the
three protocols (see the above figure).
```{r}
plot(phy_tree(ps1))
# ape::add.scale.bar()
```


## Calibration relative to the "ground truth"

```{r}
# First, we'll pick samples for estimation and cross validation.
# Pick Individuals for estimation and evaluation
set.seed(2)
sam <- sample_data(ps1) %>% as_tibble
individuals_est <- base::sample(1:8, 3, replace = FALSE) %>% as.character
individuals_eval <- 1:8 %>% as.character %>% setdiff(individuals_est)
samples_est <- sam %>% 
    filter(Individual %in% individuals_est) %$%
    Sample
samples_eval <- sam %>% 
    filter(Individual %in% individuals_eval) %$%
    Sample
sample_data(ps1)[, "Set"] <- "Other"
sample_data(ps1)[samples_est, "Set"] <- "Est"
sample_data(ps1)[samples_eval, "Set"] <- "Eval"
```

```{r}
# Estimate biases:
# (Re-generate ps1.clr to inherit the Set variable)
ps1.clr <- ps1 %>% transform_sample_counts(clr, denom = "all")
taxa <- taxa_names(ps1)
# Calculate the median clr across individuals within a protocol
tb0 <- ps1.clr %>% as_tibble %>%
    filter(Sample %in% samples_est) %>%
    group_by(Protocol) %>%
    summarize_at(taxa, median)
# Get the biases as the diff from truth
tb1 <- tb0 %>%
    gather(key = "Taxon", value = "CLR", taxa) %>%
    left_join(mock_comp, by = "Taxon", suffix = c("", "_true")) %>%
    mutate(Bias = CLR - CLR_true)
# Format for my calibration functions
biases <- tb1 %>%
    select(Taxon, Protocol, Bias) %>%
    spread(key = Protocol, value = Bias)
bias_mat <- biases %>% select(-Taxon) %>% as("matrix")
rownames(bias_mat) <- biases$Taxon
# Calibrate the full set of samples.
ps1.clr.cal <- calibrate_clr(ps1.clr, "Protocol", bias_mat)
# Objects for computing distances:
sample_data(ps.truth.clr)[, "Set"] <- "Other"
ps.clr <- prune_samples(samples_eval, ps1.clr) %>%
    merge_phyloseq(ps.truth.clr)
ps.clr.cal <- prune_samples(samples_eval, ps1.clr.cal) %>%
    merge_phyloseq(ps.truth.clr)
# Distances before/after:
d <- phyloseq::distance(ps.clr, method = 'euclidean')
d.cal <- phyloseq::distance(ps.clr.cal, method = 'euclidean')

tb0 <- usedist::dist_groups(d, sample_data(ps.clr)$Protocol) %>% as_tibble %>%
    mutate(Calibrated = "No")
tb1 <- usedist::dist_groups(d.cal, sample_data(ps.clr.cal)$Protocol) %>%
    as_tibble %>%
    mutate(Calibrated = "Yes")
tb2 <- bind_rows(tb0, tb1)
tb3 <- tb2 %>%
    filter(Item1 %in% samples_eval, Group2 == "Truth") %>%
    rename(Protocol = Group1)
```


Distance (euclidean centered log ratio) before and after calibration, on the
evaluation samples only:
```{r, fig.height = 6}
set.seed(2)
ggplot(tb3, aes(Calibrated, Distance, color = Protocol)) +
    geom_violin(draw_quantiles = c(0.5)) + 
    geom_jitter(width=0.25) + 
    facet_wrap(~Protocol)
```

```{r}
# Get a combined phyloseq with calibrated and uncalibrated samples and the truth
sample_data(ps1.clr)$Calibrated <- "No"
sample_names(ps1.clr.cal) <- sample_names(ps1.clr.cal) %>% paste0(".cal")
sample_data(ps1.clr.cal)$Calibrated <- "Yes"
sample_data(ps.truth.clr)$Calibrated <- NA
ps2.clr <- merge_phyloseq(ps1.clr, ps1.clr.cal) %>%
    subset_samples(Individual %in% c(individuals_est, individuals_eval)) %>%
    merge_phyloseq(ps.truth.clr)
```

PCA (euclidean centered log ratio) before and after calibration, showing
samples used for estimating bias ("Est") and for cross validation ("Eval"):
```{r, fig.height = 6, fig.width = 8}
p <- plot_pca(ps2.clr)
pd <- p$data %>%
    filter(Sample != "Truth") %>%
    mutate(Calibrated = switchv(Calibrated, 
            No = "Uncalibrated", Yes = "Calibrated"),
        Calibrated = factor(Calibrated, c("Uncalibrated", "Calibrated")))
truth <- p$data %>% 
    filter(Sample == "Truth") %>% 
    select(-Calibrated)
ggplot(pd, aes(x = PC1, y = PC2, color = Protocol, label = Individual, 
        shape = Set)) +
    geom_point(data = truth, aes(x = PC1, y = PC2), 
        shape = 3, size = 5, inherit.aes = FALSE) +
    geom_point() +
    scale_shape_manual(breaks = c("Est", "Eval"), values = c(1, 16)) +
    facet_grid(Calibrated ~ .) +
    labs(p$labels[1:2])
    # theme(axis.text.x = element_blank(), 
    #     axis.text.y = element_blank(),
    #     axis.ticks = element_blank())
```

Centered abundance (Ratio relative to geometric mean) before and after
calibration, showing all samples (Est and Eval), and with "ground truth" shown
by grey step function.
```{r, fig.height = 8}
tb.clr <- ps2.clr %>% as_tibble %>%
    gather(key = "Taxon", value = "CLR", taxa_names(ps1.clr)) %>%
    mutate(Taxon = factor(Taxon, species_ordered)) %>%
    filter(Sample != "Truth") %>%
    mutate(Calibrated = switchv(Calibrated, 
            No = "Uncalibrated", Yes = "Calibrated"),
        Calibrated = factor(Calibrated, c("Uncalibrated", "Calibrated")))
lvls <- tb.clr$Taxon %>% levels
# Points for step function of true abundances
tb.step <- tibble(x = seq(0.5, 10.5, by = 0.5)) %>%
    mutate(x_int = pmin(floor(x + 0.5), 10),
        Taxon = lvls[x_int]) %>%
    left_join(mock_comp, by = "Taxon")
ggplot(tb.clr, aes(x = Taxon, y = 2^CLR)) + 
    geom_point(aes(x = Taxon, y = 2^CLR, color = Protocol, 
        shape = Set),
        position = position_jitter(width=0.25, height=0)) +
    geom_step(data = tb.step, aes(x = x, y = 2^CLR), alpha=0.3) +
    ylab("Abundance / geometric mean") +
    scale_y_log10() +
    # facet_grid(.~Calibrated) +
    facet_grid(Calibrated ~ .) +
    scale_shape_manual(breaks = c("Est", "Eval"), values = c(1, 16)) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title.x = element_blank())
```

TODO: Fix clipping of x-axis label in this figure

### Estimate of C. difficile absolute abundance

Calibration allows us to improve our estimates of pathogen abundance. Here,
I am using the most abundant species from the spike-in to obtain absolute
abundance estimates of a pathogen, C. difficile. Calibration greatly improves
the accuracy of the C. difficile abundance in the evaluation samples.
(I haven't been able to figure out the scale for the x-axis yet. It's cells
per...something)
```{r}
# Get the relative abundances:
ps2.ra <- transform_sample_counts(ps2.clr, 
    function (x) {x <- 2**x; x / sum(x)})
# Estimate absolute abundances by treating Prevotella as the only spike-in
spikein <- "Prevotella_melaninogenica"
spikein_density <- mock_comp %>% filter(Taxon == spikein) %$% 2**Log2_density
# get the AAs 
ps2.aa <- ps2.ra %>%
    transform_sample_counts(function (x) {x * spikein_density / x[spikein]})
# Get a tibble for plotting
tb.aa <- as_tibble(ps2.aa) %>%
    filter(Set != "Other")
tb.aa0 <- tb.aa %>%
    filter(Set %in% "Eval")
# The true CD density
cdiff_density <- mock_comp %>% filter(Taxon == "Clostridium_difficile") %$%
    2**Log2_density
```

```{r, fig.height = 4.8, fig.width = 7.2}
my_xlab <- expression(paste("Density of ", italic("Clostridium difficile")))

p <- ggplot(tb.aa, aes(x = Clostridium_difficile, y = Protocol, 
        color = Calibrated, shape = Set)) +
    geom_vline(xintercept = cdiff_density, color = "grey") +
    geom_jitter(height = 0.1, width = 0) +
    scale_x_log10() +
    scale_shape_manual(breaks = c("Est", "Eval"), values = c(1, 16)) +
    annotate("text", x = cdiff_density, y = Inf, label = "True abundance",
        vjust = -0.5) +
    theme(plot.margin = margin(t = 1, unit = "lines")) +
    xlab(my_xlab)
gt <- ggplot_gtable(ggplot_build(p))
gt$layout$clip[gt$layout$name == "panel"] <- "off"
grid::grid.draw(gt)
```

